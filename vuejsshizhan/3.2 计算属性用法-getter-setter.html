<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>3.2 计算属性用法-getter-setter</title>
</head>
<body>

<!--挂载点-->
<div id="app">
    <h1>名称是 ：{{ fullName }}</h1>

</div>

<script src="./node_modules/vue/dist/vue.js"></script>
<script>

    var app = new Vue({
        el: '#app',
        data: {
            firstName: 'deng',
            lastName: 'zhiqiang'

        },
        computed: {
            fullName: {
                // getter用于读取
                get: function () {
                    return this.firstName + '===' + this.lastName;

                },
                // setter，写入时触发
                set: function (newVal) {
                    var names = newVal.split(' ');
                    this.firstName = names[0];
                    this.lastName = names[1];
                }
            }
        }
    });
    // 每一个计算属性都包含－个 getter 和一个 setter，我们上面的两个示例都是计算属性的默认用
    //     法 ， 只是利用了 getter 来读取。在你需要时，也可以提供一个 setter 函数 ， 当手动修改计算属性的
    //     值就像修改一个普通数据那样时，就会触发 setter 函数，执行一些自定义的操作


    //     当执行 app.fullName =’John Doe＇；时， setter 就会被调用，数据 firstName 和 lastName 都会相对
    //     更新，视图同样也会更新。
    // 绝大多数情况下，我们只会用默认的 getter 方法来读取一个计算属性，在业务中很少用到阴阳setter,
    //         所以在声明一个计算属性时，可以直接使用默认的写法，不必将 getter 和 setter 都声明。

    //  计算属性还有两个很实用的小技巧容易被忽略：
    //  一是计算属性可以依赖其他计算属性：
    //  二是计算属性不仅可以依赖当前 Vue 实例的数据，还可以依赖其他实例的数据，例

    setInterval(function () {
        app.fullName = '邓 志强';
    }, 2000)


</script>
</body>
</html>